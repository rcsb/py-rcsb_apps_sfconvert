void guess_sf_format(char *inpfile, char *format)
// guess various format
{
    char **line,outfile[256],str[512],table[256],item[256];
    char s1[80],s2[80],s3[80],s4[80],s5[80],s6[80];
    int i, nline,  n=0, n1, n2,n3,n4,n5,n6,n7,n8,n9;
    int nn7=0,kk7=0, k1,k2,k3, m1,m2, mm1=0;
    float a;
    
    FILE *fout=NULL;

    
    line=get_lines_from_file(inpfile, &nline);
    if(nline<2){
        sprintf(INFO, "Error! File (%s) is wrong! too few lines (%d)\n", inpfile, nline);
        pinfo(INFO,0);
        exit(0);
    }
    
    strcpy(outfile, "sf_format_guess.text");
    fout=fopen(outfile, "w");
    
    n1=0; //guess mmCIF
    n2=0; //guess CIF
    n3=0; //guess CNS (MAIN)
    n4=0; //guess TNT
    n5=0; //guess XSCALE based on head
    n6=0; //guess d*TREK based on head
    n7=0; //guess HKL/SCALEPACK based on head or columns
    n8=0; //guess shelx
    n9=0; //guess saint
    k1=0;k2=0;k3=0;
    m1=0;m2=0;
    
    for(i=0; i<nline; i++){
        if(i==0 && line[i][0] =='M' && line[i][1] =='T' && line[i][2] =='Z' && line[i][3] ==' ' ){
            write_format(fout,"MTZ", 10);
            strcpy(format, "MTZ");
            return;
        }
        
        n=sscanf(line[i], "%s%s%s%s%s%s", str,s2,s3,s4,s5,s6);
        rid_of_end_space(line[i]);
        
            
        if(str[0]=='_' && strchr(str, '.') ){
            if (check_category(str, table, item)){
                if (!strcmp_case(table, "_refln")){
                    if (!strcmp_case(item, "F_meas_au") || !strcmp_case(item, "F_meas")){
                        k1=1;
                    }else if (!strcmp_case(item, "intensity_meas") || !strcmp_case(item, "F_squared_meas")){
                        k2=1;
                    }else if (!strcmp_case(item, "pdbx_F_plus") || !strcmp_case(item, "pdbx_I_plus")){
                        k3=1;
                    }
                }
                if (n1++>200 || k1 || k2 || k3) break;
                
            }else if(!strncmp_case(str, "_refln_", 7)){
                if(!strcmp_case(str, "_refln_F_meas" ))k1=1;
                if(!strcmp_case(str, "_refln_F_squared_meas" ))k2=1;
                
                if (n2++>200 || k1 || k2 ) break;
            }
            
        }else if(!strncmp_case(str, "INDE", 4) ||
                 (!strncmp_case(str, "DECLare",7)&& strstr_case(line[i]+20, "RECIproca"))){
            
            if(strstr_case(line[i], "FOBS=" ) || strstr_case(line[i], "FO=" )||
               strstr_case(line[i], " F_" ) || strstr_case(line[i], "F=" ))m1++;
            
            if(strstr_case(line[i], "IOBS=" ) ||  strstr_case(line[i], "IO=" )||
               strstr_case(line[i], "I=" ))m2++;

            if(strstr_case(line[i], " FOBS " )  )mm1++;
            
            if (n3++ >300) break;
            
            
        }else if(strstr_case(line[i], "FOBS=" ) || strstr_case(line[i], "FO=" )||
                 strstr_case(line[i], "F=" )){
            
            n3++;
            if (m1++ >300) break;
            
        }else if(strstr_case(line[i], "IOBS=" ) || strstr_case(line[i], " IO=" )||
                 strstr_case(line[i], " I=" )){
            n3++;
            if (m2++ >300) break;
            
        }else if(!strncmp_case(str, "HKL", 3)){  //TNT format
            sscanf(line[i], "%*s%*s%*s%*s%f", &a);
            if(a<0)m2++;
            if (n4++ >200) break;
            
        }else if(!strncmp_case(str, "!SPACE_GROUP_NUMBER=", 20) ||  //xscale
                 !strncmp_case(str, "!UNIT_CELL_CONSTANTS=", 21) ||
                 !strncmp_case(str, "!ITEM_H=",8) ||
                 !strncmp_case(str, "!ITEM_K=",8) ||
                 !strncmp_case(str, "!ITEM_L=",8) ){
            if (++n5>4) break;
            
        }else if(!strncmp_case(str, "CRYSTAL_MOSAICITY=", 18) ||  
                 !strncmp_case(str, "CRYSTAL_SPACEGROUP=",19) ||
                 !strncmp_case(str, "CRYSTAL_UNIT_CELL=",18)  ||
                 !strncmp_case(str, "nH",2) ||
                 !strncmp_case(str, "nK",2) ||
                 !strncmp_case(str, "nL",2) ){
            
            if (++n6>5) break;
            
        }else if(((i==0 && !strcmp(str, "1") && n==1) ||
                  (i==1 && (!strcmp(str, "-985") || !strcmp(str, "-987")) && n==1) ||
		  (i==2 && strchr(str,'.') && strlen(line[i])>60)) && n==6){
            if (++n7>=3) break;  //scalepack
            
            
        }else if(i>50 && strlen(line[i])==32 ){
            
            strncpy(s1, line[i]+12, 8);
            s1[8] = '\0';
            if(atof(s1)<0) m2++; //I
            n8++;
            
        }else if(i>50 && strlen(line[i])>150 ){
            if (++n9>5) break;
        }
        
        if (i>50 && !strchr(line[i], ',')){ //HKL or shelx (if strlen==28)
            if (strlen(line[i])==28 || strlen(line[i])==35 ||
                strlen(line[i])==44 || strlen(line[i])==53){
                nn7++;
                
            }
            if (kk7++ >2000) break;
        }
        
        
    }
//    printf("numbers %d %d %d %d %d %d %d %d %d : %d %d \n", n1,n2,n3,n4,n5,n6,n7, n8, n9, nn7, kk7);
    
    if(n1>=4){ 
        if(k1==1 && k2==1){
            write_format(fout,"MMCIF", 2); //I&F

        }else if(k1==1 && k2!=1){
            write_format(fout,"MMCIF", 1); //F
        }else if(k1!=1 && k2==1){
            write_format(fout,"MMCIF", 0); //I
        }else if(k3==1){
            write_format(fout,"MMCIF", 3); //ano
        }else
            write_format(fout,"MMCIF", -1); //nothing

        strcpy(format, "MMCIF");
        
    }else if(n2>=4){
        if(k1==1 && k2==1){
            write_format(fout,"CIF", 2); //I&F
        }else if(k1==1 && k2!=1){
            write_format(fout,"CIF", 1); //F
        }else if(k1!=1 && k2==1){
            write_format(fout,"CIF", 0); //I
        }else
            write_format(fout,"CIF", -1); //nothing
        
        strcpy(format, "CIF");
        
    }else if(n3>=50 && mm1<10){
        if(m1>100 && m2>100){
            write_format(fout,"CNS", 2); //I&F
        }else if(m1>50 &&  m2<10){
            write_format(fout,"CNS", 1); //F
        }else if(m2>50 &&  m1<10){
            write_format(fout,"CNS", 0); //I
            
        }else
            write_format(fout,"CNS", -1); //nothing

        strcpy(format, "CNS");
        
    }else if(n3>=50 && mm1>10){
        write_format(fout,"xplor", 1);
        strcpy(format, "xplor");
        
    }else if(n4>=100){
        if(m2>0)
            write_format(fout,"TNT", 0);
        else
            write_format(fout,"TNT", -2);
        
        strcpy(format, "TNT");
        
    }else if(n5>=5){
        write_format(fout,"XSCALE", 0);
        strcpy(format, "XSCALE");
        
    }else if(n6>=6){
        write_format(fout,"DTREK", 0);
        strcpy(format, "DTREK");
        
    }else if(n7>1 || (nn7>=200 && nn7==kk7)){
        write_format(fout,"HKL", 0);
        strcpy(format, "HKL");

    }else if(n8>=200){
        if(m2>0)
            write_format(fout,"SHELX", 0);
        else
            write_format(fout,"SHELX", -2);
        strcpy(format, "SHELX");
        
    }else if(n9>=200){
        write_format(fout,"SAINT", 0);
        strcpy(format, "SAINT");
        
    }else{
        write_format(fout,"", -1);
    }
    if(nline)free_memory_2d(line, nline);
        
    
}

char **get_lines_from_file(char *inpfile, int *nline)
        //there is no space between lines
{
    char str[2000], **all_line=NULL;
    int m;
    FILE *fp=NULL;

    
    if((fp=fopen(inpfile, "r"))==NULL){
        printf("Can not open file (%s) in get_lines_from_file\n", inpfile);
        *nline=0;
        return NULL;
//        open_file_error(inpfile, "get_lines_from_file");
    }
    
    
    m=0;
    while (fgets(str, sizeof str, fp) != NULL) {
        if(is_space_line(str)<=0)continue;
        m++;
    }
    rewind(fp);
    all_line=new char *[m+1];

    m=0;
    while (fgets(str, sizeof str, fp) != NULL) {
        if(is_space_line(str)<=0)continue;
         all_line[m] = new char [strlen(str) +1];
        strcpy(all_line[m],str);
        m++;
    }
    *nline =m;
    fclose(fp);
    return (all_line);
}

int is_space_line(const char *str)
// n=0, is a space line; n!=0 NOT.    
{
    int i, n=0, len;

    len = strlen(str);
    for(i=0; i<len; i++){
        if(isspace(str[i])) continue;
        n++;
    }
    return n;
}


void pinfo(char *info, int id)
//write all the log infor. about the SF file
{
    if (strstr_case(info, "Warning") || strstr_case(info, "Error")){
        fprintf(FTMP1, "%s\n",info);
        printf("%s\n",info);
    }else{
        if (id==0){
            fprintf(FTMP2, "%s\n", info);
            printf("%s\n",info);
        }else if (id==1){
            fprintf(FTMP2, "%s\n",info);
        }else if (id==2){
            printf("%s\n", info);
        }
    }
    
}

int strcmp_case (const char *s1, const char *s2){
  int same =0;
  char a1, a2;

  while (s1[0]!='\0' && s2[0]!='\0' && !same) {
    a1 = tolower(s1[0]);
    a2 = tolower(s2[0]);
    if (a1!=a2)
    {
      if (a1<a2)
      {
    same = 1;
      }
      else
      {
    same = -1;
      }
    }
    s1++; s2++;
  }
  if ((s1[0]!='\0'|| s2[0]!='\0')&& same==0)
  {
    if (s1[0]!='\0')
    {
      same = 1;
    }
    else
    {
      same = -1;
    }
  }
  return same;
}

int strncmp_case (const char *s1, const char *s2, int n){

  int same =0;
  char a1, a2;
  int i=0;
  
  i=0;
  while (s1[0]!='\0' && s2[0]!='\0' && !same && i<n) {
    a1 = tolower(s1[0]);
    a2 = tolower(s2[0]);
    if (a1!=a2)
    {
      if (a1<a2)
      {
    same = 1;
      }
      else
      {
    same = -1;
      }
    }
    s1++; s2++;
    i++;
  }
  if ((s1[0]!='\0'|| s2[0]!='\0')&& same==0)
    if (i<n) {
      if (s1[0]!='\0')
    same = 1;
      else
    same = -1;
    }
  return same;
}

char* strstr_case(const char *s1, const char *s2) 
{ 
    int i,j,k; 

    for(i=0;s1[i];i++) 
        for(j=i,k=0;tolower(s1[j])==tolower(s2[k]);j++,k++) 
            if(!s2[k+1]) 
                return (char*) (s1+i); 

    return NULL; 
}

void  write_format(FILE *fout, const char *format, int key)
{
    int len=0;

    len=strlen(format);
    if(len<1){
        pinfo_local(fout, "Sorry! format can not be predicted. Check input file!");
        
    }else{
        fprintf(fout,"FORMAT=%s\n", format);
        
        if(key==-1){
            pinfo_local(fout,"Data type can not be predicted. Check input file!");
        }
        
        if(key==-2){
            pinfo_local(fout,"Data type may be Amplitude(F), Check file to confirm!");
        }
        
        if(key==0){
            pinfo_local(fout, "Data type is Intensity (I).");
        }
        
        if(key==1) {
            pinfo_local(fout, "Data type is Amplitude (F).");
        }
        
        if(key==2) {
            pinfo_local(fout,"Data type are both Amplitude (F) and Intensity (I).");
        }
        
        if(key==3) {
            pinfo_local(fout,"Data type are anomolous signal.");
        }
        
        if(key==10) {
            pinfo_local(fout,"Data type for MTZ file can be auto_converted.");
        }
        
    }
    fclose(fout);
}

void  pinfo_local(FILE *fout, const char *format)
{
    printf("%s\n", format);
    fprintf(fout, "%s\n", format);
}

void rid_of_end_space(char *str)
/* get rid of space after last word */
{
    int i=0,  n=0, len;

    len=strlen(str);
    for(i=len-1; i>=0; i--){
        if(isspace(str[i]))
            n++;
        else
            break;
    }
    str[len-n]='\0';
    if(iscntrl(str[len-n-1]))str[len-n-1]='\0';
}

int  check_category(const char *str, char *category, char *item)
// get possible category between _ and . (no space in between)     
// return 0 if not category, else return 1;
{
    int  n=0, i=0, id=0;
    char  *tmp=NULL;

    strcpy(category, "");
    strcpy(item, "");
    tmp = new char[strlen(str)+1];
    
    n=sscanf(str,"%s",tmp);
        
    if(n!=1 || tmp[0] != '_' || !strchr(tmp,'.') || strlen(tmp)<=1 || strlen(tmp)>150){
        id=0;
    }else{
        strcpy(item, strchr(tmp,'.')+1);
    
        for(i=0; tmp[i]!='.'; i++){category[i]=tmp[i];}
        category[i] = '\0';
        
        if((strlen(category)<1 || strchr(category,'.')) ||
           (strlen(item)<1 || strchr(item,'.')) ) {
            id=0;
        }else{
            id=1;
        }
    }
    delete []tmp;
    return id;
    
}

